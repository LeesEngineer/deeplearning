</br>

<p>之前做过 Image Classification，也是输入一个 64*64 的图像然后尝试判断</p>

<p>计算机视觉的一个例子是目标检测，通常在目标检测中，不仅要找出图片中的物体，还要圈出他们</p>

<p>另一个例子是 Neural Style Transfer</p>

<p>之前的一个挑战是输入可以任意大，假如你有 1000 * 1000 * 3 的输入特征（X 有三百万维）就算第一个隐藏层只有 1000 个 unit，那权重矩阵也非常大了</p>

<p><b>有这么多的参数，很难获得足够的数据以避免神经网络过拟合</b>。同时，训练一个有三百万参数的神经网络，对内存的需求也很大</p>

<p>为了解决该问题需要更好的运用卷积运算</p>

</br>

# Edge detection example

</br>

<p>卷积运算是卷积神经网络的基础组成单元</p>

<p>在之前讨论过神经网络的前几层是怎样检测边缘的（有点凝聚态物理的意味），后面几层可能会检测对象的某些部分，更后面几层会检测到某些整个的对象</p>

![QQ_1747057187053](https://github.com/user-attachments/assets/0ff7d305-2739-43d0-b23e-b76104387d67)

<p>例子：</p>

![QQ_1747057284911](https://github.com/user-attachments/assets/27619823-1fc5-4d82-86eb-1d9eab2ea0b6)

<p>给出一张照片，让电脑算出图片中的物体是什么，</p>

<b>做的第一件事可能是检测图片中的垂直边缘(如图栅栏和行人的轮廓在这个垂直边缘检测中检测出来了)</b>

![QQ_1747057403809](https://github.com/user-attachments/assets/2f427ba4-5a01-4027-9daf-c9034fe28750)

<p>也许想要水平检测</p>

![QQ_1747057621538](https://github.com/user-attachments/assets/0f88bfe3-cac3-4470-9009-d8ec35ba79dc)

</br>

## 如何实现图像中的边缘检测

</br>

![QQ_1747057709193](https://github.com/user-attachments/assets/572f7538-dac8-4355-95b9-296a554a8685)

<p>一个 6*6*1 的矩阵，所以是一个灰度图像。为了检测这个图像的垂直边缘，能做的是建立一个 3*3 的矩阵（在池化过程中叫做过滤器 filter，有时也叫核 kernel）</p>

```
1 0 -1
1 0 -1
1 0 -1
```

<p>运算：</p>

![QQ_1747058058549](https://github.com/user-attachments/assets/ce71b6b8-a59d-406e-a64a-24f51fab1ac3)

<p>左边的矩阵可以容易的理解为一个图像。右边的也许可以理解为另一个图像（这就是一个垂直边缘检测器）</p>

<p>关于为什么这是在进行垂直边缘检测，为了更好的解释，用一个简化了的图像：</p>

![QQ_1747058469905](https://github.com/user-attachments/assets/0f5eb6c5-e07e-4134-86da-6089a90b99f7)

<p>变化为图像是：</p>

![QQ_1747058559555](https://github.com/user-attachments/assets/e9915472-076f-4c98-9940-058fd48de07d)

<p>在输出图像中更亮的区域在中间，这与检测出的垂直边缘相对应</p>

<p>在这里检测出来的边缘看起来很厚，那只是因为在这个例子中用了一个很小的图像，如果用一个 1000*1000 的图像就有很好的效果。这个在中间的明亮区域只是用输出图像的方式来表示有一个强垂直边缘正好在图像的中心</p>

</br>

# More edge detection

</br>

<p>已经了解了卷积操作是如何进行垂直边缘检测的，接下来讨论正边缘和负边缘的差别（由亮变暗和由暗变亮的边缘过渡）以及其他几种边缘检测器，以及如何让算法来学习边缘检测器（而不是手动设定）</p>

![QQ_1747144467451](https://github.com/user-attachments/assets/d8151634-08e8-4640-8ff6-8460aaf39e9c)

<p>将颜色翻转，得到：</p>

![QQ_1747144519426](https://github.com/user-attachments/assets/8eaa378c-4a4e-4dc1-a2c1-de9f215091fb)

<p>亮暗关系是反的，30 变为 -30 表示由暗变亮，如果不在乎二者的区别，可以取绝对值，但这个过滤器确实能够区分两种边界</p>

<hr>

<p>关于 Horizontal：(使用水平边界检测器)</p>

![QQ_1747144999445](https://github.com/user-attachments/assets/5bed50f8-1200-4a98-9092-56ffb109faf7)

<p>像 30 和 -30 代表<b>检测器在这里检测到了一个很强的正边界</b>，因为这只是一个 6*6 的 image，10 和 -10 反映了过滤取捕捉到了左边界的一部分和右边界的一部分，如果是一个 1000*1000 的 image，就不会有这些元素为 10 的过渡区域，这些过渡值相对于图片的大小会非常小</p>

<hr>

<p>关于过滤器用哪些数字组合仍然存在很大的争议</p>

```
1 0 -1
2 0 -2
1 0 -1
```

<p>如上称为 Sobel 过滤器，优点在于给中间行赋予了更大的权重，<b>从而使之更加稳定</b></p>

```
3  0 -3
10 0 -10
3  0 -3
```

<p>称为 Scharr 过滤器，有略微不同的性质</p>

<hr>

<p>如果想检测一些复杂的图片的边界，可以将矩阵里的元素当作参数，通过反向传播来学习得到他们的数值，可能得到更加善于博主哦特征的过滤器</p>

</br>

# Padding

</br>

<p>为了构建深层神经网络，一个非常需要使用的对基本的卷积操作的改进是 Padding</p>

<p>如果有一个 n*n 的图片，并且想使用一个 f*f 的过滤器，<b>输出的维度将会是 (n-f+1)*(n-f+1)</b></p>

<p>有两个缺陷：</p>

- 如果每一次使用一个卷积操作，图像都会缩小。也许并不希望，每次检测边界或者其他特征时，都缩小图片

- 图片角落或边际上的像素，只会在输出中被使用一次，因为他只通过那个过滤器一次，而图片中间的像素会有很多次过滤器的重叠。所以相对而言，角落或边界上的像素被使用的次数很少，<b>丢失了许多图片靠近边界的信息</b>

<p>要做的是在进行卷积操作前，用额外的边缘填充图片。通常使用 0 来填充，如果 p 是填充的数量，输出则变成了 (n + 2p - f +1)*(n + 2p - f +1)。大大降低了边界和角落信息被忽略的严重程度</p>

<p>关于填充，有两个常见的选择：</p>

- Valid 卷积：意思是没有填充

- Same 卷积：Pad so that output size is the same as the input size. p = (f - 1) / 2

<p>计算机视觉领域，f 通常使用奇数，大概有两个原因</p>

- 如果是偶数，则会需要一些不对称的填充

- 其次是如果使用一个奇数大小的过滤器，这样可以有一个中心位置。在计算机视觉领域，有一个特殊点是很好的，这样就可以描述过滤器的位置

</br>

# Strided convolutions

</br>

<p>步幅卷积</p>
 
```
n*n by f*f
padding p
stride s
    -> floor(((n + 2p -f) / 2) + 1) * floor(((n + 2p -f) / 2) + 1)
```

</br>

# Convolutions over volumes

</br>

<p>讨论如何对三维图像进行卷积</p>

<p>如果想对不是对灰度图像，而是对 RGB 图像（不再是 height * width，而是 height * width * #channels）检测特征，不应使用 3*3 的过滤器，而应该使用三维过滤器(3*3*3)。</p>

<p>图像的通道数必须和过滤器的通道数相符</p>







































































































































































































































































































































































































































































































































